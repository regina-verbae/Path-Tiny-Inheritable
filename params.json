{"name":"Path::Tiny::Inheritable","tagline":"Drop-in replacement for Path::Tiny that allows inheritance","body":"# Path::Tiny::Inheritable\r\n\r\nDrop-in replacement for `Path::Tiny` that allows inheritance\r\n\r\nAs such, it is less *tiny* than `Path::Tiny`, but does adhere\r\nto a more traditional object-oriented design.\r\n\r\n## Features\r\n\r\n* All `Path::Tiny` methods are available\r\n* All constructors (except `path`) may be called with a bare class name or as a method from an existing object.\r\n```perl\r\n    my $path1 = Path::Tiny::Inheritable->new(...);\r\n    my $path2 = $path1->new(...);\r\n```\r\n* `Path::Tiny` methods which return `Path::Tiny` objects have been overridden to return objects constructed using `$self->new()`, guaranteeing that they will be of the same class type as `$self`.\r\n* Auto-stringification is enabled and inheritable.\r\n\r\n## Simple example subclass\r\n\r\n```perl\r\npackage My::Path::Tiny;\r\n\r\nuse parent qw(Path::Tiny::Inheritable Exporter);\r\nour @EXPORT = qw(path);\r\n\r\n# Subroutine constructor must be redefined to replicate\r\n#   Path::Tiny behavior\r\nsub path {\r\n    __PACKAGE__->new(@_);\r\n}\r\n\r\n# Override or define new methods and go!\r\n```\r\n\r\n## Methods\r\n\r\nSee `Path::Tiny` documentation for available methods.\r\n\r\nThe only new method available in `Path::Tiny::Inheritable` is `path_tiny`, which returns the `Path::Tiny` object stored in `$self`.\r\n\r\n## Details of inheritance\r\n\r\nSubclasses of `Path::Tiny::Inheritable` inherit the following `CLASSNAME->new()`-style constructors:\r\n\r\n* `CLASSNAME->new()`\r\n* `CLASSNAME->cwd()`\r\n* `CLASSNAME->rootdir()`\r\n* `CLASSNAME->tempfile()`\r\n* `CLASSNAME->tempdir()`\r\n\r\nThere is no `CLASSNAME->path()` interface for the classic `path` constructor.  The `path` constructor is not inheritable, but if it is desired by the subclass, it can be defined simply as follows:\r\n\r\n```perl\r\nsub path {\r\n    __PACKAGE__->new(@_);\r\n}\r\n```\r\n\r\nIf subroutine-style constructors are desired for the remaining constructors (as in `Path::Tiny`), the following is the recommended way to do so (in order to preserve inheritance for child classes):\r\n\r\n```perl\r\nsub cwd {\r\n    my $class = shift // __PACKAGE__;\r\n    $class->SUPER::cwd;\r\n}\r\n\r\nsub rootdir {\r\n    my $class = shift // __PACKAGE__;\r\n    $class->SUPER::rootdir;\r\n}\r\n\r\n# tempfile,tempdir may accept arguments so it is necessary to test whether\r\n#   the first argument looks like a classname or calling object\r\nsub tempfile {\r\n    my $class = eval { $_[0]->isa(__PACKAGE__) }\r\n        ? shift\r\n        : __PACKAGE__;\r\n    $class->SUPER::tempfile;\r\n}\r\n\r\nsub tempdir {\r\n    my $class = eval { $_[0]->isa(__PACKAGE__) }\r\n        ? shift\r\n        : __PACKAGE__;\r\n    $class->SUPER::tempdir;\r\n}\r\n```\r\n\r\n## Best practices for adding/overriding methods\r\n\r\n### Use `$self->new()` instead of `path()`\r\n\r\nIf the subclass overrides or defines a method which returns a path object, in order to preserve inheritance,\r\nuse the `$self->new()` style of construction instead of `__PACKAGE__->new()` or `path()`.\r\n\r\n### Overriding `new()`\r\n\r\nThis package relies heavily on the fact that `$self->new(...)` constructs a new object of the same type as `$self`.  Overriding `new()` is certainly allowed, but must implement that same behavior, otherwise things will almost certainly break.\r\n\r\nThe structure of the `Path::Tiny::Inheritable` object is simply this:\r\n\r\n```perl\r\n{ path => <Path::Tiny object> }\r\n```\r\n\r\nIf an overridden `new` constructor changes where the `Path::Tiny` object is stored, the `path_tiny` method must also be overridden in order for inherited methods to work.\r\n\r\n## Acknowledgments\r\n\r\nThis package would obviously not exist without the mighty work of David Golden in [Path::Tiny](https://github.com/dagolden/Path-Tiny).","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}